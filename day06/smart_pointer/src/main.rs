fn main() {
    /*
     *  相关的概念 
     *  指针: 一个变量在内存中包含的是一个地址(指向其他数据)
     *  Rust 中最常见的指针就是 “引用”
     *  引用:
     *   - 使用 &
     *   - 借用它指向的值
     *   - 没有其余开销
     *   - 最常见的指针
    */

    // TODO : 智能指针
    /*
     *  - 行为和指针相似
     *  - 有额外的元数据和功能 
     * */ 

    //  TODO : 引用计数 (reference counting) 智能指针类型

    /*
     *  通过记录所有者的数量,使一份数据被多个所有者同时持有
     *  并在没有任何所有者时自动清理数据
     * 
     *  TODO :  引用和智能指针的其他不同
     *  - 引用    :  只借用数据
     *  - 智能指针 :  很多时候都拥有它所指向的数据
     * 
     * 
     * 智能指定的例子:
     *  - String 和 Vec<T>
     *  - 都拥有一片内存区域,且允许用户对其操作
     *  - 还拥有元数据(例如容量等)
     *  - 提供额外的功能和保障(String 保障其数据是合法的UTF - 8 编码)
     * 智能指针的的实现
     *  - 智能指针通常使用struct 实现,并且实现了 :
     *    - Deref 和 Drop 这两个trait
     *  - Deref trait : 允许智能指针struct 的实例像引用一样使用
     *  - Drop  trait : 允许你自定义当智能指针实例走出作用域时的代码
     * 
     * */ 

    //  TODO : 本章内容
    /*
     *  介绍标准库中常见的智能指针
     *  - Box<T> : 在heap 内从上的分配值
     *  - Rc <T> : 启用多重所有权的引用计数类型
     *  - Ref<T> : RefMut<T> 通过RefCell<T> 访问 : 在运行时而不是编译时强制借用规则的类型
     * 此外:
     *  - 内部可变模式: 不可变类型暴露出可修改其内部值的API
     *  - 引用循环 :他们如何泄露内存,以及如何防止其发生.
     * */ 

}
